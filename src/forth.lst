# file opened: src\forth.asm
  1   0000              ; Zed8E FORTH - A direct threaded FORTH for the Z-80
  2   0000              ;
  3   0000              ; This FORTH is designed to run on bare bones hardware with no O/S or
  4   0000              ; other forms of interference or support.
  5   0000              ;
  6   0000
  7   0000                  OUTPUT rom_image.dat
  8   0000
  9   0000                  include "helpers.i"
# file opened: src\helpers.i
  1+  0000              ; Zed8E FORTH - A direct threaded FORTH for the Z-80
  2+  0000              ;
  3+  0000              ; Some helper macros
  4+  0000
  5+  0000              ;   A macro to step the origin with padding so the output file is not crap.
  6+  0000                  macro pad addr
  7+  0000 ~                assert ($<=addr), "Error, code overrun"
  8+  0000 ~                if $ < addr             ; Add padding
  9+  0000 ~                    block addr-$,$C7
 10+  0000 ~                endif
 11+  0000                  endm
 12+  0000
# file closed: src\helpers.i
 10   0000
 11   0000                  org $0000           ; The system reset entry point.
 12   0000
 13   0000 F3               di                  ; Make certain that interrupts are disabled.
 14   0001 31 FE FF         ld      SP,init_sp  ; Set up the SP register.
 15   0004 C3 6E 00         jp      start_up
 16   0007
 17   0007                  pad     $0008       ; Entry point for rst #$08 or do_does
 17   0007             >    assert ($<=$0008), "Error, code overrun"
 17   0007             >    if $ < $0008             ; Add padding
 17   0007 C7          >        block $0008-$,$C7
 17   0008             >    endif
 18   0008 FD 70 00         ld      (iy+0),b    ; Push the IP onto the RS
 19   000B FD 2B            dec     iy
 20   000D FD 71 00         ld      (iy+0),c
 21   0010 FD 2B            dec     iy
 22   0012 C1               pop     bc
 23   0013 DD E9            jp      ix          ; NEXT
 24   0015
 25   0015                  ; Note rst #$10 is not available.
 26   0015
 27   0015                  pad     $0018       ; Entry point for rst #$18 or do_const
 27   0015             >    assert ($<=$0018), "Error, code overrun"
 27   0015             >    if $ < $0018             ; Add padding
 27   0015 C7 C7 C7    >        block $0018-$,$C7
 27   0018             >    endif
 28   0018 E1               pop     hl
 29   0019 5E               ld      e,(hl)
 30   001A 23               inc     hl
 31   001B 56               ld      d,(hl)
 32   001C D5               push    de
 33   001D DD E9            jp      ix          ; NEXT
 34   001F
 35   001F                  pad     $0020       ; Entry point for rst #$20 or do_var
 35   001F             >    assert ($<=$0020), "Error, code overrun"
 35   001F             >    if $ < $0020             ; Add padding
 35   001F C7          >        block $0020-$,$C7
 35   0020             >    endif
 36   0020 DD E9            jp      ix          ; NEXT
 37   0022
 38   0022                  pad     $0028       ; Entry point for rst #$20 or do_colon
 38   0022             >    assert ($<=$0028), "Error, code overrun"
 38   0022             >    if $ < $0028             ; Add padding
 38   0022 C7 C7 C7... >        block $0028-$,$C7
 38   0026             >    endif
 39   0028 FD 70 00         ld      (iy+0),b    ; Push the IP onto the RS
 40   002B FD 2B            dec     iy
 41   002D FD 71 00         ld      (iy+0),c
 42   0030 FD 2B            dec     iy
 43   0032 C1               pop     bc
 44   0033 DD E9            jp      ix          ; NEXT
 45   0035
 46   0035                  ; Note rst #$30 is not available.
 47   0035
 48   0035                  pad     $0038       ; Entry point for rst #$38 or interrupt mode 1.
 48   0035             >    assert ($<=$0038), "Error, code overrun"
 48   0035             >    if $ < $0038             ; Add padding
 48   0035 C7 C7 C7    >        block $0038-$,$C7
 48   0038             >    endif
 49   0038 F5               push    af          ; Save all registers.
 50   0039 C5               push    bc
 51   003A D5               push    de
 52   003B E5               push    hl
 53   003C 08               ex      af,af'
 54   003D D9               exx
 55   003E F5               push    af
 56   003F C5               push    bc
 57   0040 D5               push    de
 58   0041 E5               push    hl
 59   0042 DD E5            push    ix
 60   0044 FD E5            push    iy
 61   0046
 62   0046 76               halt                ; Place holder for now.
 63   0047
 64   0047 FD E1            pop     iy          ; Restore all registers
 65   0049 DD E1            pop     ix
 66   004B E1               pop     hl
 67   004C D1               pop     de
 68   004D C1               pop     bc
 69   004E F1               pop     af
 70   004F 08               ex      af,af'
 71   0050 D9               exx
 72   0051 E1               pop     hl
 73   0052 D1               pop     de
 74   0053 C1               pop     bc
 75   0054 F1               pop     af
 76   0055 ED 4D            reti
 77   0057
 78   0057                  pad     $0066       ; Entry point for Nonmaskable interrupt.
 78   0057             >    assert ($<=$0066), "Error, code overrun"
 78   0057             >    if $ < $0066             ; Add padding
 78   0057 C7 C7 C7... >        block $0066-$,$C7
 78   005B             >    endif
 79   0066 76               halt                ; Place holder for now.
 80   0067
 81   0067              next:
 82   0067 0A               ld      a,(bc)      ; Fetch the next instruction.
 83   0068 03               inc     bc
 84   0069 6F               ld      l,a
 85   006A 0A               ld      a,(bc)
 86   006B 03               inc     bc
 87   006C 67               ld      h,a
 88   006D E9               jp      hl          ; Execute it.
 89   006E
 90   006E              start_up:
 91   006E FD 21 67 00      ld      iy, next    ; IY always points to next.
 92   0072 76               halt                ; Place holder for now.
 93   0073
 94   0073              ; Beyond this point is RAM. No bytes should be generated for this region.
 95   0073                  org     $8000
 96   8000              ram_start:
 97   8000
 98   8000                  org     $FFFE
 99   FFFE              init_sp:
100   FFFE
# file closed: src\forth.asm
